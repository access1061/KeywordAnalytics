import sys
import os
import time
import json
import re
import pandas as pd
import requests
from dotenv import load_dotenv

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QPushButton, QLabel, QTextEdit, QTableWidget,
    QTableWidgetItem, QHeaderView, QProgressBar, QMessageBox,
    QLineEdit, QFileDialog
)
from PyQt6.QtGui import QIcon, QColor
from PyQt6.QtCore import Qt, QThread, QObject, pyqtSignal

# (ì´ì „ ë²„ì „ì˜ ëª¨ë“  í•µì‹¬ ë¡œì§ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤)
# Signature, load_cookies_from_auth_file, get_naver_ad_keywords, get_blog_post_count
# save_auth_logic, Worker í´ë˜ìŠ¤ ë“±...

# --- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ í´ë˜ìŠ¤ ---
class KeywordApp(QMainWindow):
    def __init__(self):
        super().__init__()
        # ... (ì´ì „ __init__ ì½”ë“œì™€ ëŒ€ë¶€ë¶„ ë™ì¼)

        self.create_trend_fetch_tab()
        self.create_analysis_tab()
        # â–¼â–¼â–¼â–¼â–¼ [ì¶”ê°€] ìë™ì™„ì„± íƒ­ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ â–¼â–¼â–¼â–¼â–¼
        self.create_autocomplete_tab()
        # â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²
        
        load_dotenv("api.env")
        # ... (ì´í•˜ __init__ ì½”ë“œ ë™ì¼)

    # ... (create_settings_bar, create_trend_fetch_tab, create_analysis_tab ë“± ì´ì „ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)

    def create_autocomplete_tab(self):
        """3. ìë™ì™„ì„± í‚¤ì›Œë“œ íƒ­ UI ìƒì„±"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # ì»¨íŠ¸ë¡¤ ì˜ì—­
        control_widget = QWidget()
        control_layout = QHBoxLayout(control_widget)
        control_layout.setContentsMargins(0,0,0,0)
        
        self.autocomplete_input = QLineEdit()
        self.autocomplete_input.setPlaceholderText("ìë™ì™„ì„± í‚¤ì›Œë“œë¥¼ ê²€ìƒ‰í•  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”...")
        self.autocomplete_search_button = QPushButton("ìë™ì™„ì„± ê²€ìƒ‰")
        self.autocomplete_copy_button = QPushButton("í‚¤ì›Œë“œ â†’ ë¶„ì„ íƒ­ìœ¼ë¡œ ë³µì‚¬")
        self.autocomplete_export_button = QPushButton("ì—‘ì…€ë¡œ ì €ì¥")

        control_layout.addWidget(QLabel("ê²€ìƒ‰ì–´:"), 0)
        control_layout.addWidget(self.autocomplete_input, 1)
        control_layout.addWidget(self.autocomplete_search_button, 0)
        control_layout.addWidget(self.autocomplete_copy_button, 0)
        control_layout.addWidget(self.autocomplete_export_button, 0)

        # ê²°ê³¼ í…Œì´ë¸”
        self.autocomplete_table = QTableWidget()
        headers = ["ìë™ì™„ì„± í‚¤ì›Œë“œ"]
        self.autocomplete_table.setColumnCount(len(headers))
        self.autocomplete_table.setHorizontalHeaderLabels(headers)
        self.autocomplete_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

        layout.addWidget(control_widget)
        layout.addWidget(self.autocomplete_table)
        self.tabs.addTab(tab, "ìë™ì™„ì„± í‚¤ì›Œë“œ ìˆ˜ì§‘")

        # ì‹œê·¸ë„ ì—°ê²°
        self.autocomplete_search_button.clicked.connect(self.start_autocomplete_search)
        self.autocomplete_input.returnPressed.connect(self.start_autocomplete_search)
        self.autocomplete_copy_button.clicked.connect(self.copy_autocomplete_to_analyzer)
        self.autocomplete_export_button.clicked.connect(self.export_autocomplete_to_excel)

    # --- ìŠ¤ë ˆë“œ ë° ë¡œì§ ì‹¤í–‰ ë©”ì„œë“œ ---
    # ... (start_trend_fetching, start_competition_analysis ë“± ì´ì „ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
    
    def start_autocomplete_search(self):
        keyword = self.autocomplete_input.text().strip()
        if not keyword:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
            return
        
        self.autocomplete_search_button.setDisabled(True)
        self.autocomplete_table.setRowCount(0)
        self.run_worker(self.autocomplete_worker, self.on_autocomplete_finished, keyword=keyword)
        
    # --- ì›Œì»¤ í•¨ìˆ˜ (ë°±ê·¸ë¼ìš´ë“œ ë¡œì§) ---
    # ... (fetch_trends_worker, analyze_competition_worker ë“± ì´ì „ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
    
    def autocomplete_worker(self, worker_instance, keyword):
        """ë„¤ì´ë²„ ìë™ì™„ì„± APIë¥¼ í˜¸ì¶œí•˜ëŠ” ì›Œì»¤ í•¨ìˆ˜"""
        worker_instance.log.emit("INFO", f"'{keyword}' ìë™ì™„ì„± í‚¤ì›Œë“œ ê²€ìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
        
        base_url = "https://ac.search.naver.com/nx/ac"
        params = {"q": keyword, "q_enc": "UTF-8", "st": "100", "r_format": "json"}
        headers = {"User-Agent": "Mozilla/5.0"}
        
        try:
            resp = requests.get(base_url, params=params, headers=headers, timeout=5)
            resp.raise_for_status()
            data = resp.json()
            
            results = []
            if data.get("items") and len(data["items"]) > 0:
                for item in data["items"][0]:
                    results.append(item[0])
            
            worker_instance.log.emit("SUCCESS", f"âœ… {len(results)}ê°œì˜ ìë™ì™„ì„± í‚¤ì›Œë“œë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
            return results
        except requests.exceptions.RequestException as e:
            raise Exception(f"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {e}")
        except json.JSONDecodeError:
            raise Exception("JSON íŒŒì‹± ì˜¤ë¥˜: ì„œë²„ ì‘ë‹µì„ í™•ì¸í•˜ì„¸ìš”.")

    # --- ìŠ¬ë¡¯ í•¨ìˆ˜ (UI ì—…ë°ì´íŠ¸) ---
    # ... (on_trend_fetching_finished, on_analysis_finished ë“± ì´ì „ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)

    def on_autocomplete_finished(self, keywords):
        self.autocomplete_table.setRowCount(len(keywords))
        for row_idx, keyword in enumerate(keywords):
            self.autocomplete_table.setItem(row_idx, 0, QTableWidgetItem(keyword))
        self.autocomplete_table.resizeColumnsToContents()
        self.autocomplete_search_button.setDisabled(False)
        self.log_message("SUCCESS", "ìë™ì™„ì„± í‚¤ì›Œë“œ ìˆ˜ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
        
    # --- ìœ í‹¸ë¦¬í‹° ë° ê¸°íƒ€ UI í•¨ìˆ˜ ---
    # ... (copy_trends_to_analyzer ë“± ì´ì „ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)

    def copy_autocomplete_to_analyzer(self):
        rows = self.autocomplete_table.rowCount()
        if rows > 0:
            keywords = [self.autocomplete_table.item(row, 0).text() for row in range(rows)]
            current_text = self.analysis_input_widget.toPlainText().strip()
            new_text = "\n".join(keywords)
            
            # ê¸°ì¡´ ë‚´ìš©ì— ì¶”ê°€
            final_text = f"{current_text}\n{new_text}" if current_text else new_text
            
            self.analysis_input_widget.setPlainText(final_text.strip())
            self.tabs.setCurrentIndex(1) # ë¶„ì„ íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
            self.log_message("INFO", f"{len(keywords)}ê°œ í‚¤ì›Œë“œë¥¼ ë¶„ì„ íƒ­ìœ¼ë¡œ ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.")
        else:
            QMessageBox.information(self, "ì•Œë¦¼", "ë¨¼ì € ìë™ì™„ì„± í‚¤ì›Œë“œë¥¼ ê²€ìƒ‰í•´ì£¼ì„¸ìš”.")
            
    def export_autocomplete_to_excel(self):
        rows = self.autocomplete_table.rowCount()
        if rows == 0:
            QMessageBox.warning(self, "ê²½ê³ ", "ì—‘ì…€ë¡œ ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        keywords = [self.autocomplete_table.item(row, 0).text() for row in range(rows)]
        df = pd.DataFrame(keywords, columns=['ìë™ì™„ì„± í‚¤ì›Œë“œ'])
        
        # íŒŒì¼ ì €ì¥ ëŒ€í™”ìƒì ì—´ê¸°
        filename, _ = QFileDialog.getSaveFileName(self, "ì—‘ì…€ë¡œ ì €ì¥", f"autocomplete_{self.autocomplete_input.text()}.xlsx", "Excel Files (*.xlsx)")
        if filename:
            try:
                df.to_excel(filename, index=False)
                self.log_message("SUCCESS", f"âœ… ì„±ê³µ! '{filename}' íŒŒì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
                QMessageBox.information(self, "ì„±ê³µ", f"'{filename}' íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            except Exception as e:
                self.log_message("ERROR", f"ğŸš¨ ì—‘ì…€ ì €ì¥ ì‹¤íŒ¨: {e}")
                QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì—‘ì…€ íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{e}")

# (ì´í•˜ ëª¨ë“  ë‹¤ë¥¸ í•¨ìˆ˜ëŠ” ì´ì „ ë²„ì „ê³¼ ë™ì¼í•©ë‹ˆë‹¤.)